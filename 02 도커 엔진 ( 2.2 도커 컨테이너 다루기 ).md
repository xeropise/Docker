### **2.2 도커 컨테이너 다루기**

- 이제 도커 컨테이너의 기초적인 사용법을 알아보자. 도커를 편하게 쓰기 위해 GUI 를 지원하는 Kitematic 이라는 도구가 있지만 CLI(Command Line Interface) 기준으로 배워보도록 하자.

#### 2.2.1 컨테이너 생성

- 도커를 사용하기에 앞서 설치된 도커 엔진의 버전을 확인하자. 새로운 PC나 서버에서 도커를 사용한다면 먼저 버전을 확인하는 것이 좋다.

```
docker -v
```

- 버전을 확인했다면 첫 번쨰 컨테이너를 생성해보자. **[docker run](https://docs.docker.com/engine/reference/commandline/run/)** 명령어는 컨테이너를 생성하고 실행하는 역할을 한다.

```
Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

- 도커 데스크탑에서 추천하는 명령어와 책에서 추천하는 명령어 2개 모두 실행해 보았다.

![캡처](https://user-images.githubusercontent.com/50399804/120431145-0c6d8b00-c3b3-11eb-9a28-a1aa8659fc78.JPG)

![캡처2](https://user-images.githubusercontent.com/50399804/120431188-1f805b00-c3b3-11eb-833b-51007aab2c25.JPG)

- 2개의 컨테이너가 생성되었다. [근데 명령어에 run 뒤로 -i, -d 등 옵션이 달려있는데 어떤 역할을 하는걸까?](https://docs.docker.com/engine/reference/commandline/run/)

- docker 명령어로 컨테이너를 생성 및 실행과 동시에 컨테이너 내부로 들어왔다. 쉘의 사용자와 호스트 이름이 변경된 것이 컨테이너 내부에 들어와 있다는 것을 나타낸다. 컨테이너에서 기본 사용자는 root 이고 호스트이름은 무작위의 16진수 해시값이다. (무작위의 16진수 해시값은 컨테이너의 고유한 ID의 앞 일부분이다.)

- docker run 명령어로 컨테이너를 생성할 때, -i 옵션으로 상호 입출력을, -t 옵션으로 tty를 활성화해서 bash 쉘을 사용하도록 컨테이너를 설정했다. docker run 명령어에서 이 두 옵션 중 하나라도 사용하지 않으면 쉘을 정상적으로 사용할 수 없다.

- **컨테이너와 호스트의 파일시스템은 서로 독립적이므로** ls 명령어로 파일시스템을 확인해보면 아무것도 설치되어 있지않다.

![캡처3](https://user-images.githubusercontent.com/50399804/120432321-bdc0f080-c3b4-11eb-8aca-d6067f64fdd6.JPG)

- 컨테이너 내부에서 호스트의 도커 환경으로 돌아와보자. 컨테이너 내부에서 빠져나오는 방법은 두 가지가 있다.
- 첫 번째 방법은 컨테이너 쉘에서 exit 를 입력하거나 Ctrl + D 를 입력하는 방법이 있다. 그런데 컨테이너 내부에서 빠져나오면서 동시에 컨테이너를 정지시킨다. exit 명령어를 사용하자.

- 두 번째 방법으로는 컨테이너를 정지하지 않고 빠져나오는 것으로 Ctrl + P, Ctrl + Q 를 입력하는 것이다. exit 명령어는 배시 쉘을 종료함으로써 컨테이너를 정지시킴과 동시에 컨테이너에서 빠져나오지만 Ctrl + P, Q를 사용하면 단순히 컨테이너의 쉘에서만 빠져나오기 때문에 컨테이너 애플리케이션을 개발하는 목적으로 컨테이너를 사용할 때는 이 방법을 많이 쓴다.

- 이 방법을 이용해 CentOS8 이미지를 사용하는 컨테이너를 생성하는 예제에서 사용해 보자.

- 컨테이너 내부에서 호스트로 되돌아와 컨테이너를 다시 생성해보자. 도커 공식 이미지 저장소에서 CentOS:8 이미지를 내려받아보자. [docker pull](https://docs.docker.com/engine/reference/commandline/pull/) 명령어는 이미지를 내려받을 때 사용한다.

```
Usage:  docker pull [OPTIONS] NAME[:TAG|@DIGEST]

Pull an image or a repository from a registry

Options:
  -a, --all-tags                Download all tagged images in the repository
      --disable-content-trust   Skip image verification (default true)
      --platform string         Set platform if server is multi-platform
                                capable
  -q, --quiet                   Suppress verbose output
```

```
C:\Users\whrbq>docker pull centos:8
8: Pulling from library/centos
7a0437f04f83: Pull complete
Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1
Status: Downloaded newer image for centos:8
docker.io/library/centos:8
```

- 이미지를 정상적으로 내려받았는지 확인해 보자. [docker images](https://docs.docker.com/engine/reference/commandline/images/) 명령어는 도커 엔진에 존재하는 이미지의 목록을 확인한다.

```
C:\Users\whrbq>docker images
REPOSITORY               TAG       IMAGE ID       CREATED        SIZE
ubuntu                   14.04     13b66b487594   2 months ago   197MB
docker/getting-started   latest    3ba8f2ff0727   2 months ago   27.9MB
centos                   8         300e315adb2f   5 months ago   209MB
```

- 컨테이너를 생성할 때는 run 명령어가 아닌 [create](https://docs.docker.com/engine/reference/commandline/create/) 명령어를 사용할 수도 있다. centos:8 이미지로 컨테이너를 생성해보자. --name 옵션에는 컨테이너의 이름을 설정할 수 있다.

```
C:\Users\whrbq>docker create --help

Usage:  docker create [OPTIONS] IMAGE [COMMAND] [ARG...]

Create a new container

.. 옵션 생략
```

- run 명령어와의 차이점은 컨테이너 내부로는 들어가지 않는다. create 명령어는 컨테이너를 생성만 할 뿐이다. 이번에는 [docker start](https://docs.docker.com/engine/reference/commandline/start/) 명령어와 [docker attach](https://docs.docker.com/engine/reference/commandline/attach/) 명령어를 써서 컨테이너를 시작하고 내부로 들어가자. attach는 컨테이너의 내부로 들어가는 명령어 이다.

```
C:\Users\whrbq>docker start mycentos
mycentos

C:\Users\whrbq>docker attach mycentos
[root@eef221ba5f8a /]#
```

- Ctrl+ P, Q 를 입력해 컨테이너에서 빠져나오자. 컨테이너를 생성하기 위해 run, create, start 명령어를 사용했다. run 명령어는 pull, create, start 명령어를 일괄적으로 실행한 후 attach 가 가능한 컨테이너라면 컨테이너 내부로 들어간다.

- 그러나 create 명령어는 도커 이미지를 pull 한 뒤에 컨테이너를 생성만 할 뿐 start, attach 를 실행하지는 않는다. 보통은 컨테이너를 생성함과 동시에 시작하기 때문에 run 명령어를 더 많이 사용한다.

- 참고로, 컨테이너를 대상하는 모든 명령어는 컨테이너 이름 대신 ID 를 쓸 수 있다. ID의 이름이 너무 길 때는 앞의 2~3자만 입력해도 된다. 단 앞의 ID가 일치하는 다른 컨테이너가 있을 경우에는 어떤 것인지 알 수없으므로 글자를 더 입력하자.

```
docker start dd06c5cb6bf4

docker start dd0
```

---

#### 2.2.2 컨테이너 목록 확인

- CentOS 컨테이너에서 호스트로 되돌아와 지금까지 생성한 컨테이너의 목록을 확인하자.

- docker ps 명령어는 정지되지 않은 컨테이너만 출력한다. 즉, exit 를 사용해 빠져나온 컨테이너는 정지 상태이기 때문에 컨테이너 목록에 출력되지 않지만, Ctrl + P, Q 를 입력해 빠져나온 컨테이너는 실행 중이기 때문에 컨테이너 목록에 출력된다.

```
C:\Users\whrbq>docker ps --help

Usage:  docker ps [OPTIONS]

List containers

Options:
  -a, --all             Show all containers (default shows just running)
  -f, --filter filter   Filter output based on conditions provided
      --format string   Pretty-print containers using a Go template
  -n, --last int        Show n last created containers (includes all
                        states) (default -1)
  -l, --latest          Show the latest created container (includes all
                        states)
      --no-trunc        Don't truncate output
  -q, --quiet           Only display container IDs
  -s, --size            Display total file sizes
```

```
C:\Users\whrbq>docker ps
CONTAINER ID   IMAGE      COMMAND       CREATED         STATUS         PORTS     NAMES
eef221ba5f8a   centos:8   "/bin/bash"   8 minutes ago   Up 3 seconds             mycentos
```

- CONTAINER ID : 컨테이너에게 자동으로 할당되는 고유한 ID이다. ps 에서는 일부분만 확인할 수 있지만, [docker inspect](https://docs.docker.com/engine/reference/commandline/inspect/) 명령어를 사용하면 전체 ID를 확인할 수 있다.

- IMAGE : 컨테이너를 생성할 때 사용된 이미지의 이름이다.

- COMMAND : 컨테이너가 시작될 때 실행될 명령어이다. 대부분 이미지에 미리 내장되어 있기 때문에 별도로 설정할 필요는 없으나 위의 경우 /bin/bash 명령어가 실행됐으므로 상호 입출력이 가능한 쉘 환경을 사용할 수 있었다. 이미지에 내장된 커맨드는 docker run 이나 create 명령어의 맨 끝에 입력해서 컨테이너를 생성할 때 덮어쓸 수 있다. 예를 들면 docker run 명령어로 생성되는 컨테이너는 실행될 때마다 'echo hello world!' 를 실행한다.

```
docker run -i -t ubuntu:14.04 echo hello world!
```

- 그러나 위 명령어로 생성된 컨테이너는 이미지에 내장된 커맨드인 /bin/bash 를 덮어쓰기 때문에 상호 입출력이 가능한 쉘이 실행되지 않아 'hello world!' 라는 내용만 출력되고 컨테이너가 종료된다.

- CREATED : 컨테이너가 생성되고 난 뒤 흐른 시간을 나타낸다.

- STATUS : 컨테이너의 상태를 나타내며, 컨테이너가 실행 중임을 나타내는 'Up', 종료된 상태인 'Exited', 일시 중지된 상태인 'Pause' 등이 있다.

- PORTS : 컨테이너가 개방한 포트와 호스트에 연결한 포트를 나열한다. 앞에서 컨테이너를 생성할 떄는 외부에 노출하도록 설정하지 않았으므로 아무것도 출력되지 않는다.

- NAMES : 컨테이너의 고유한 이름이다. 컨테이너를 생성할 떄 --name 옵션으로 이름을 설정하지 않으면 도커엔진이 임의로 형용사와 명사를 무작위로 조합해 이름을 설정한다. docker rename 명령어를 사용하면 컨테이너 이름을 변경할 수 있다.

```
docker rename angry_morse my_container
```

---

#### 2.2.3 컨테이너 삭제

- 더 이상 사용하지 않는 컨테이너를 삭제할 때는 [docker rm](https://docs.docker.com/engine/reference/commandline/rm/) 명령어를 사용하자. 한번 삭제한 컨테이너는 복구할 수 없으므로 신중하게 결정하자.

```
C:\Users\whrbq>docker ps
CONTAINER ID   IMAGE      COMMAND       CREATED          STATUS          PORTS     NAMES
eef221ba5f8a   centos:8   "/bin/bash"   24 minutes ago   Up 15 minutes             mycentos

C:\Users\whrbq>docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                      PORTS     NAMES
eef221ba5f8a   centos:8       "/bin/bash"   24 minutes ago   Up 15 minutes                         mycentos
dab784f31d8a   ubuntu:14.04   "/bin/bash"   35 minutes ago   Exited (0) 33 minutes ago             compassionate_dijkstra

C:\Users\whrbq>docker rm mycentos
Error response from daemon: You cannot remove a running container eef221ba5f8a077408bd3a0b432c49095589dc0d010670fcd914a6139e6d7109. Stop the container before attempting removal or force remove

C:\Users\whrbq>docker stop mycentos
mycentos

C:\Users\whrbq>docker rm mycentos
mycentos

C:\Users\whrbq>docker rm dab
dab

C:\Users\whrbq>docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

C:\Users\whrbq>docker ps -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

- 실행 중인 컨테이너를 삭제하는 다른 방법으로는 rm 명령어에 -f 옵션을 추가하면 된다.

- 도커를 사용하다 보면 연습용으로 생성한 컨테이너가 너무 많아 일일이 삭제하기 귀찮은 경우가 있는데, 이런 경우에는 prune 명령어를 사용해서 모든 컨테이너를 삭제할 수 있다.

```
C:\Users\whrbq>docker container prune
WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N] y
Total reclaimed space: 0B
```

- 혹은 docker ps 로 출력한 컨테이너 리스트를 변수로 모든 컨테이너를 멈추고, 제거할 수 있다.

```
# docker stop $(docker ps -a -q)
# docker rm $(docker ps -a -q)
```

- docker -q 는 ID 만 출력하는 역할을 한다. 컨테이너를 삭제하면 컨테이너의 데이터를 모두 잃게 되므로 연습용으로 도커를 활용할 경우에만 위 명령어를 사용하도록 하자.

---

#### 2.2.4 컨테이너를 외부에 노출

- 컨테이너는 가상 머신과 마찬가지로 가상 IP 주소를 할당받는다. 기본적으로 도커는 컨테이너에 172.17.0.x의 IP를 순차적으로 할당한다. 컨테이너를 새롭게 생성한 후 ifconfig 명령어로 컨테이너의 네트워크 인터페이스를 확인해 보자.

```
C:\Users\whrbq>docker run -i -t --name network_test ubuntu:14.04
root@09672ae4a96f:/# ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:02
          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:7 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:606 (606.0 B)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
```

- 도커의 NAT IP 인 172.17.0.2 를 할당받은 eth0 인터페이스와 로컬 호스트인 lo 인터페이스가 있다. 아무런 설정을 하지 않았다면 이 컨테이너는 외부에서 접근할 수 없으며, 도커가 설치된 호스트에서만 접근할 수 있다.

- 외부에 컨테이너의 애플리케이션을 노출하기 위해서는 eth()의 IP와 포트를 호스트의 IP와 포트에 바인딩해야 한다.

- 컨테이너에서 호스트로 빠져 나온 뒤, 다음 명령어를 입력해 컨테이너를 생성하자. 이 컨테이너에 아파치 웹 서버를 설치해 외부에 노출할 것이다.

```
docker run -i -t --name mywebserver -p 80:80 ubuntu:14.04
```

- 이전의 run 예제와 다른 점은 -p 옵션을 추가하였는데, -p 옵션은 컨테이너의 포트를 호스트의 포트와 바인딩해 연결할 수 있게 설정한다. -p 옵션의 입력 형식은 다음과 같다.

```
[호스트의 포트]:[컨테이너의 포트]
```

- 호스트의 7777번 포트를 컨테이너의 80번 포트와 연결하려면 7777:80 을, 호스트의 특정 IP 를 사용하려면 192.168.0.100:7777:80 과 같이 바인딩할 IP와 포트를 명시한다. 또한 여러 개의 포트를 외부에 개방하려면 -p 옵션을 여러 번 써서 설정하면 된다.

```
docker run -i -t -p 3306:3306 -p 19.16.0.100:7777:80 ubuntu:14.04
```

- 아파치 웹 서버는 기본적으로 80번 포트를 사용하므로 여기서는 컨테이너의 80번 포트를 호스트와 연결한다.

- \-p 80과 같이 입력하면 컨테이너의 80번 포트를 쓸 수 있는 호스트의 포스트 중 하나와 연결하는데, 컨테이너를 생성하는 시점에서 호스트의 어느 포트와 연결됐는지 알 수 없으므로 docker ps 명령어를 통해 PORTS 항목을 확인해야 한다.

- 컨테이너를 생성해 내부로 들어오면 다음과 같은 명령어를 차례로 입력해 아파치 웹 서버를 설치하자.

```
apt-get update
apt-get install apache2 -y
service aptach2 start
```

- 아파치 웹 서버의 설치 및 실행이 완료되면 localhost:80 으로 접근하자.

  ![캡처](https://user-images.githubusercontent.com/50399804/120439231-3f1c8100-c3bd-11eb-961a-adb3b1aff09a.JPG)

- 손쉽게 아파치 웹 서버 컨테이너를 생성하고 시작했다. 실제로 아파치 서버가 설치된 것은 컨테이너 내부이므로 호스트에는 어떠한 영향도 주지 않는다.

- 호스트의 IP와 포트를 컨테이너의 IP와 포트로 연결한다는 개념은 매우 중요하다. 아파치 웹 서버는 172 대역을 가진 컨테이너의 NAT IP와 80번 포트로 서비스하므로 여기에 접근하려면 172.17.0.x:80 의 주소로 접근해야 한다. 그러나 도커의 포트 포워딩 옵션인 -p 를 써서 호스트와 컨테이너를 연결했으므로 호스트의 IP와 포트를 통해 접근할 수 있다.

**[포트 포워딩?](https://ko.wikipedia.org/wiki/%ED%8F%AC%ED%8A%B8_%ED%8F%AC%EC%9B%8C%EB%94%A9)**

<img width="530" alt="docker-network" src="https://user-images.githubusercontent.com/50399804/120439737-d08bf300-c3bd-11eb-8125-9a5f02d9889f.png">

> 호스트 IP의 80번 포트로 접근 -> 80번 포트는 컨테이너의 80번 포트로 포워딩 -> 웹 서버 접근

<img width="845" alt="img (3)" src="https://user-images.githubusercontent.com/50399804/120439958-121c9e00-c3be-11eb-9b9f-297d33db9030.png">
